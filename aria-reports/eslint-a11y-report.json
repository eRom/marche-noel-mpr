[{"filePath":"/Users/recarnot/dev/marche-noel-mpr/axe.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/postcss.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/public/sw-template.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Invalid character.","line":1,"column":0}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"# Service Worker Configuration Template\n\n```javascript\n// public/sw.js\nconst CACHE_NAME = 'marche-noel-mpr-v1';\nconst urlsToCache = [\n  '/',\n  '/programme',\n  '/boutique',\n  '/merci',\n  '/share',\n  '/manifest.json'\n];\n\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => cache.addAll(urlsToCache))\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n      .then((response) => {\n        return response || fetch(event.request);\n      })\n  );\n});\n```\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/scripts/generate-icons.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":31},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":25},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":29}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nconst sharp = require('sharp');\nconst fs = require('fs');\nconst path = require('path');\n\n// Configuration des icônes à générer\nconst iconConfigs = [\n  // Apple Touch Icon\n  { name: 'apple-touch-icon.png', size: 180, format: 'png' },\n  \n  // Favicons\n  { name: 'favicon-16x16.png', size: 16, format: 'png' },\n  { name: 'favicon-32x32.png', size: 32, format: 'png' },\n  { name: 'favicon.ico', size: 32, format: 'ico' },\n  \n  // PWA Icons\n  { name: 'icon-192.png', size: 192, format: 'png' },\n  { name: 'icon-512.png', size: 512, format: 'png' },\n  \n  // Standard icons\n  { name: 'icon.png', size: 64, format: 'png' },\n  { name: 'icon.svg', size: 64, format: 'svg' },\n  { name: 'logo.svg', size: 64, format: 'svg' }\n];\n\nasync function generateIcons() {\n  const sourcePath = path.join(__dirname, '../logo.png');\n  const outputDir = path.join(__dirname, '../public');\n  \n  // Vérifier que le fichier source existe\n  if (!fs.existsSync(sourcePath)) {\n    console.error('❌ Logo source non trouvé:', sourcePath);\n    process.exit(1);\n  }\n  \n  console.log('🚀 Génération des icônes à partir de:', sourcePath);\n  console.log('📁 Dossier de sortie:', outputDir);\n  \n  // Créer le dossier public s'il n'existe pas\n  if (!fs.existsSync(outputDir)) {\n    fs.mkdirSync(outputDir, { recursive: true });\n  }\n  \n  let successCount = 0;\n  let errorCount = 0;\n  \n  for (const config of iconConfigs) {\n    try {\n      const outputPath = path.join(outputDir, config.name);\n      \n      console.log(`⏳ Génération de ${config.name} (${config.size}x${config.size})...`);\n      \n      let sharpInstance = sharp(sourcePath)\n        .resize(config.size, config.size, {\n          fit: 'contain',\n          background: { r: 255, g: 255, b: 255, alpha: 0 } // Transparent background\n        });\n      \n      // Configuration spécifique selon le format\n      switch (config.format) {\n        case 'png':\n          sharpInstance = sharpInstance.png({ quality: 90 });\n          break;\n        case 'ico':\n          sharpInstance = sharpInstance.png({ quality: 90 });\n          break;\n        case 'svg':\n          // Pour SVG, on génère d'abord en PNG puis on convertit\n          sharpInstance = sharpInstance.png({ quality: 90 });\n          break;\n      }\n      \n      await sharpInstance.toFile(outputPath);\n      \n      // Conversion spéciale pour ICO\n      if (config.format === 'ico') {\n        const pngPath = outputPath.replace('.ico', '.png');\n        await sharp(sourcePath)\n          .resize(config.size, config.size, {\n            fit: 'contain',\n            background: { r: 255, g: 255, b: 255, alpha: 0 }\n          })\n          .png()\n          .toFile(pngPath);\n        \n        // Note: Pour une vraie conversion ICO, il faudrait une librairie spécialisée\n        // Pour l'instant, on garde le PNG avec l'extension .ico\n        console.log(`⚠️  Note: ${config.name} généré en PNG (extension .ico)`);\n      }\n      \n      console.log(`✅ ${config.name} généré avec succès`);\n      successCount++;\n      \n    } catch (error) {\n      console.error(`❌ Erreur lors de la génération de ${config.name}:`, error.message);\n      errorCount++;\n    }\n  }\n  \n  console.log('\\n📊 Résumé de la génération:');\n  console.log(`✅ Succès: ${successCount}`);\n  console.log(`❌ Erreurs: ${errorCount}`);\n  console.log(`📁 Total: ${iconConfigs.length} fichiers`);\n  \n  if (errorCount === 0) {\n    console.log('\\n🎉 Toutes les icônes ont été générées avec succès!');\n  } else {\n    console.log('\\n⚠️  Certaines icônes n\\'ont pas pu être générées.');\n  }\n}\n\n// Exécution du script\nif (require.main === module) {\n  generateIcons().catch(console.error);\n}\n\nmodule.exports = { generateIcons, iconConfigs };\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/scripts/generate-og-image.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadImage' is assigned a value but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'registerFont' is assigned a value but never used.","line":1,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":46},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":1,"column":51,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":1,"endColumn":68},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":2,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":2,"endColumn":25},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":29}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { createCanvas, loadImage, registerFont } = require('canvas');\nconst fs = require('fs');\nconst path = require('path');\n\n// Configuration\nconst WIDTH = 1280;\nconst HEIGHT = 800;\nconst OUTPUT_PATH = path.join(__dirname, '../public/og.png');\n\n// Couleurs du thème Noël\nconst COLORS = {\n  background: '#0f172a', // Bleu foncé\n  primary: '#dc2626', // Rouge Noël\n  secondary: '#16a34a', // Vert sapin\n  accent: '#fbbf24', // Or\n  text: '#ffffff',\n  textSecondary: '#e2e8f0',\n  snow: '#f8fafc'\n};\n\n// Fonction pour créer un dégradé\nfunction createGradient(ctx, x1, y1, x2, y2, colorStops) {\n  const gradient = ctx.createLinearGradient(x1, y1, x2, y2);\n  colorStops.forEach(stop => {\n    gradient.addColorStop(stop.position, stop.color);\n  });\n  return gradient;\n}\n\n// Fonction pour dessiner des flocons de neige\nfunction drawSnowflake(ctx, x, y, size) {\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.strokeStyle = COLORS.snow;\n  ctx.lineWidth = 2;\n  ctx.globalAlpha = 0.8;\n  \n  for (let i = 0; i < 6; i++) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, size);\n    ctx.stroke();\n    ctx.rotate(Math.PI / 3);\n  }\n  \n  ctx.restore();\n}\n\n// Fonction pour dessiner des étoiles\nfunction drawStar(ctx, x, y, size, color) {\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.fillStyle = color;\n  ctx.globalAlpha = 0.9;\n  \n  ctx.beginPath();\n  for (let i = 0; i < 5; i++) {\n    const angle = (i * 4 * Math.PI) / 5;\n    const radius = i % 2 === 0 ? size : size * 0.4;\n    const px = Math.cos(angle) * radius;\n    const py = Math.sin(angle) * radius;\n    if (i === 0) ctx.moveTo(px, py);\n    else ctx.lineTo(px, py);\n  }\n  ctx.closePath();\n  ctx.fill();\n  \n  ctx.restore();\n}\n\n// Fonction pour dessiner des sapins\nfunction drawTree(ctx, x, y, size) {\n  ctx.save();\n  ctx.translate(x, y);\n  \n  // Tronc\n  ctx.fillStyle = '#8b4513';\n  ctx.fillRect(-size * 0.1, size * 0.3, size * 0.2, size * 0.4);\n  \n  // Feuillage\n  ctx.fillStyle = COLORS.secondary;\n  ctx.beginPath();\n  ctx.moveTo(0, -size * 0.5);\n  ctx.lineTo(-size * 0.4, size * 0.2);\n  ctx.lineTo(size * 0.4, size * 0.2);\n  ctx.closePath();\n  ctx.fill();\n  \n  // Étoile au sommet\n  drawStar(ctx, 0, -size * 0.5, size * 0.1, COLORS.accent);\n  \n  ctx.restore();\n}\n\n// Fonction pour dessiner un rectangle arrondi\nfunction drawRoundedRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n}\n\nasync function generateOGImage() {\n  // Créer le canvas\n  const canvas = createCanvas(WIDTH, HEIGHT);\n  const ctx = canvas.getContext('2d');\n  \n  // Fond avec dégradé\n  const backgroundGradient = createGradient(ctx, 0, 0, 0, HEIGHT, [\n    { position: 0, color: COLORS.background },\n    { position: 0.7, color: '#1e293b' },\n    { position: 1, color: '#0f172a' }\n  ]);\n  \n  ctx.fillStyle = backgroundGradient;\n  ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  \n  // Ajouter des flocons de neige\n  for (let i = 0; i < 30; i++) {\n    const x = Math.random() * WIDTH;\n    const y = Math.random() * HEIGHT;\n    const size = Math.random() * 8 + 4;\n    drawSnowflake(ctx, x, y, size);\n  }\n  \n  // Ajouter des étoiles scintillantes\n  for (let i = 0; i < 20; i++) {\n    const x = Math.random() * WIDTH;\n    const y = Math.random() * HEIGHT * 0.6;\n    const size = Math.random() * 6 + 3;\n    drawStar(ctx, x, y, size, COLORS.accent);\n  }\n  \n  // Ajouter des sapins en arrière-plan\n  const treePositions = [\n    { x: 100, y: HEIGHT - 150, size: 80 },\n    { x: 200, y: HEIGHT - 120, size: 60 },\n    { x: WIDTH - 150, y: HEIGHT - 140, size: 70 },\n    { x: WIDTH - 250, y: HEIGHT - 110, size: 50 }\n  ];\n  \n  treePositions.forEach(tree => {\n    drawTree(ctx, tree.x, tree.y, tree.size);\n  });\n  \n  // Zone de contenu principal\n  const contentX = WIDTH * 0.1;\n  const contentY = HEIGHT * 0.2;\n  const contentWidth = WIDTH * 0.8;\n  const contentHeight = HEIGHT * 0.6;\n  \n  // Fond semi-transparent pour le contenu\n  ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';\n  drawRoundedRect(ctx, contentX, contentY, contentWidth, contentHeight, 20);\n  ctx.fill();\n  \n  // Bordure dorée\n  ctx.strokeStyle = COLORS.accent;\n  ctx.lineWidth = 3;\n  drawRoundedRect(ctx, contentX, contentY, contentWidth, contentHeight, 20);\n  ctx.stroke();\n  \n  // Titre principal\n  ctx.fillStyle = COLORS.text;\n  ctx.font = 'bold 64px Arial, sans-serif';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  \n  const titleText = 'Marché de Noël';\n  const titleY = contentY + 40;\n  ctx.fillText(titleText, contentX + contentWidth / 2, titleY);\n  \n  // Sous-titre\n  ctx.fillStyle = COLORS.accent;\n  ctx.font = 'bold 48px Arial, sans-serif';\n  const subtitleText = 'du MPR de Nantes';\n  const subtitleY = titleY + 80;\n  ctx.fillText(subtitleText, contentX + contentWidth / 2, subtitleY);\n  \n  // Dates\n  ctx.fillStyle = COLORS.textSecondary;\n  ctx.font = '36px Arial, sans-serif';\n  const dateText = '15 au 24 décembre 2024';\n  const dateY = subtitleY + 80;\n  ctx.fillText(dateText, contentX + contentWidth / 2, dateY);\n  \n  // Description\n  ctx.fillStyle = COLORS.textSecondary;\n  ctx.font = '24px Arial, sans-serif';\n  const descriptionText = 'Artisans locaux • Produits authentiques • Ambiance festive';\n  const descriptionY = dateY + 60;\n  ctx.fillText(descriptionText, contentX + contentWidth / 2, descriptionY);\n  \n  // Icônes décoratives\n  const iconY = descriptionY + 80;\n  const iconSpacing = 80;\n  const startX = contentX + contentWidth / 2 - (iconSpacing * 2);\n  \n  // Icône sapin\n  drawTree(ctx, startX, iconY, 30);\n  \n  // Icône cadeau (carré avec ruban)\n  ctx.save();\n  ctx.translate(startX + iconSpacing, iconY);\n  ctx.fillStyle = COLORS.primary;\n  ctx.fillRect(-15, -10, 30, 20);\n  ctx.fillStyle = COLORS.accent;\n  ctx.fillRect(-15, -2, 30, 4);\n  ctx.fillRect(-2, -10, 4, 20);\n  ctx.restore();\n  \n  // Icône étoile\n  drawStar(ctx, startX + iconSpacing * 2, iconY, 20, COLORS.accent);\n  \n  // Icône cœur\n  ctx.save();\n  ctx.translate(startX + iconSpacing * 3, iconY);\n  ctx.fillStyle = COLORS.primary;\n  ctx.beginPath();\n  ctx.arc(-8, 0, 8, Math.PI, 0, false);\n  ctx.arc(8, 0, 8, Math.PI, 0, false);\n  ctx.lineTo(0, 20);\n  ctx.closePath();\n  ctx.fill();\n  ctx.restore();\n  \n  // Icône sapin\n  drawTree(ctx, startX + iconSpacing * 4, iconY, 30);\n  \n  // Sauvegarder l'image\n  const buffer = canvas.toBuffer('image/png');\n  fs.writeFileSync(OUTPUT_PATH, buffer);\n  \n  console.log(`✅ Image OpenGraph générée avec succès : ${OUTPUT_PATH}`);\n  console.log(`📐 Dimensions : ${WIDTH} × ${HEIGHT} pixels`);\n}\n\n// Exécuter la génération\ngenerateOGImage().catch(console.error);\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/scripts/generate-screenshots.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":25},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":29},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":6,"column":76,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":6,"endColumn":105}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nconst puppeteer = require('puppeteer');\nconst fs = require('fs');\nconst path = require('path');\nconst { puppeteerConfig, viewportConfigs, screenshotConfig, waitConfig } = require('./puppeteer-config');\n\nasync function generateScreenshots() {\n  console.log('📸 Génération des captures d\\'écran pour le manifest...');\n\n  const browser = await puppeteer.launch(puppeteerConfig);\n\n  try {\n    const page = await browser.newPage();\n\n    // Configuration des viewports\n    const viewports = [\n      {\n        name: 'mobile',\n        config: viewportConfigs.mobile,\n        filename: 'screenshot-mobile.png'\n      },\n      {\n        name: 'desktop',\n        config: viewportConfigs.desktop,\n        filename: 'screenshot-desktop.png'\n      }\n    ];\n\n    for (const viewport of viewports) {\n      console.log(`📱 Génération capture ${viewport.name} (${viewport.config.width}x${viewport.config.height})...`);\n      \n      // Configuration du viewport\n      await page.setViewport(viewport.config);\n\n      // Configuration de l'user agent pour mobile\n      if (viewport.config.isMobile) {\n        await page.setUserAgent(viewport.config.userAgent);\n      }\n\n      // Naviguer vers la page d'accueil\n      await page.goto('http://localhost:3000', {\n        waitUntil: waitConfig.waitUntil,\n        timeout: waitConfig.timeout\n      });\n\n      // Attendre que les animations se terminent\n      await new Promise(resolve => setTimeout(resolve, waitConfig.animationDelay));\n\n      // Attendre que les images se chargent\n      await new Promise(resolve => setTimeout(resolve, waitConfig.imageLoadDelay));\n\n      // Prendre la capture d'écran\n      const screenshotPath = path.join(__dirname, '..', 'public', viewport.filename);\n      await page.screenshot({\n        path: screenshotPath,\n        ...screenshotConfig\n      });\n\n      // Vérifier que le fichier a été créé\n      if (fs.existsSync(screenshotPath)) {\n        const stats = fs.statSync(screenshotPath);\n        const sizeKB = Math.round(stats.size / 1024);\n        console.log(`✅ Capture ${viewport.name} sauvegardée: ${viewport.filename} (${sizeKB}KB)`);\n      } else {\n        console.error(`❌ Erreur: Fichier ${viewport.filename} non créé`);\n      }\n    }\n\n    console.log('🎉 Génération des captures terminée !');\n\n  } catch (error) {\n    console.error('❌ Erreur lors de la génération des captures:', error);\n    throw error;\n  } finally {\n    await browser.close();\n  }\n}\n\n// Vérifier si le serveur est en cours d'exécution\nasync function checkServer() {\n  try {\n    const response = await fetch('http://localhost:3000');\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function main() {\n  console.log('🔍 Vérification du serveur de développement...');\n  \n  const serverRunning = await checkServer();\n  if (!serverRunning) {\n    console.log('⚠️  Serveur non détecté sur http://localhost:3000');\n    console.log('💡 Démarrez le serveur avec: npm run dev');\n    console.log('🔄 Relancez ce script après avoir démarré le serveur');\n    process.exit(1);\n  }\n\n  await generateScreenshots();\n}\n\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = { generateScreenshots };\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/scripts/lighthouse-test.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":41},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":50},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":25},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":6,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":6,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'category' is defined but never used.","line":150,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is defined but never used.","line":193,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":193,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is defined but never used.","line":197,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":197,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'promise' is defined but never used.","line":258,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":258,"endColumn":50}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nconst lighthouse = require('lighthouse').default;\nconst chromeLauncher = require('chrome-launcher');\nconst fs = require('fs');\nconst path = require('path');\n\n// Configuration des tests\nconst configs = {\n  desktop: {\n    name: 'Desktop',\n    settings: {\n      formFactor: 'desktop',\n      throttling: {\n        rttMs: 40,\n        throughputKbps: 10240,\n        cpuSlowdownMultiplier: 1,\n        requestLatencyMs: 0,\n        downloadThroughputKbps: 0,\n        uploadThroughputKbps: 0\n      },\n      screenEmulation: {\n        mobile: false,\n        width: 1350,\n        height: 940,\n        deviceScaleFactor: 1,\n        disabled: false\n      }\n    }\n  },\n  mobile: {\n    name: 'Mobile',\n    settings: {\n      formFactor: 'mobile',\n      throttling: {\n        rttMs: 150,\n        throughputKbps: 1638.4,\n        cpuSlowdownMultiplier: 4,\n        requestLatencyMs: 0,\n        downloadThroughputKbps: 0,\n        uploadThroughputKbps: 0\n      },\n      screenEmulation: {\n        mobile: true,\n        width: 375,\n        height: 667,\n        deviceScaleFactor: 2,\n        disabled: false\n      }\n    }\n  }\n};\n\n// Configuration Lighthouse\nconst lighthouseConfig = {\n  extends: 'lighthouse:default',\n  settings: {\n    onlyAudits: [\n      'first-contentful-paint',\n      'largest-contentful-paint',\n      'first-meaningful-paint',\n      'speed-index',\n      'cumulative-layout-shift',\n      'total-blocking-time',\n      'interactive',\n      'performance-budget',\n      'render-blocking-resources',\n      'unused-css-rules',\n      'unused-javascript',\n      'modern-image-formats',\n      'uses-optimized-images',\n      'uses-text-compression',\n      'uses-responsive-images',\n      'efficient-animated-content',\n      'preload-lcp-image',\n      'uses-rel-preconnect',\n      'uses-rel-preload',\n      'font-display',\n      'unminified-css',\n      'unminified-javascript',\n      'uses-webp-images',\n      'uses-avif-images',\n      'legacy-javascript',\n      'dom-size',\n      'no-document-write',\n      'uses-http2',\n      'uses-long-cache-ttl',\n      'total-byte-weight',\n      'offscreen-images',\n      'render-blocking-resources',\n      'unused-css-rules',\n      'unused-javascript',\n      'uses-webp-images',\n      'uses-avif-images',\n      'modern-image-formats',\n      'uses-optimized-images',\n      'uses-responsive-images',\n      'efficient-animated-content',\n      'preload-lcp-image',\n      'uses-rel-preconnect',\n      'uses-rel-preload',\n      'font-display',\n      'unminified-css',\n      'unminified-javascript',\n      'legacy-javascript',\n      'dom-size',\n      'no-document-write',\n      'uses-http2',\n      'uses-long-cache-ttl',\n      'total-byte-weight',\n      'offscreen-images'\n    ]\n  }\n};\n\nasync function runLighthouseTest(url, config, configName) {\n  console.log(`\\n🚀 Démarrage du test Lighthouse ${configName}...`);\n  \n  const chrome = await chromeLauncher.launch({\n    chromeFlags: ['--headless', '--no-sandbox', '--disable-gpu']\n  });\n\n  try {\n    const options = {\n      logLevel: 'info',\n      output: 'json',\n      onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],\n      port: chrome.port,\n      ...config\n    };\n\n    const runnerResult = await lighthouse(url, options, lighthouseConfig);\n    \n    // Sauvegarder le rapport complet\n    const reportDir = path.join(__dirname, '../lighthouse-reports');\n    if (!fs.existsSync(reportDir)) {\n      fs.mkdirSync(reportDir, { recursive: true });\n    }\n    \n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const reportPath = path.join(reportDir, `lighthouse-${configName.toLowerCase()}-${timestamp}.json`);\n    fs.writeFileSync(reportPath, runnerResult.report);\n    \n    // Afficher les résultats\n    const lhr = runnerResult.lhr;\n    console.log(`\\n📊 Résultats Lighthouse ${configName}:`);\n    console.log('=' .repeat(50));\n    \n    // Scores par catégorie\n    Object.entries(lhr.categories).forEach(([category, data]) => {\n      const score = Math.round(data.score * 100);\n      const emoji = score >= 90 ? '🟢' : score >= 50 ? '🟡' : '🔴';\n      console.log(`${emoji} ${data.title}: ${score}/100`);\n    });\n    \n    // Métriques Core Web Vitals\n    console.log('\\n🎯 Core Web Vitals:');\n    const audits = lhr.audits;\n    \n    if (audits['largest-contentful-paint']) {\n      const lcp = audits['largest-contentful-paint'];\n      console.log(`📈 LCP: ${lcp.displayValue} (${lcp.score >= 0.9 ? '🟢' : lcp.score >= 0.5 ? '🟡' : '🔴'})`);\n    }\n    \n    if (audits['first-input-delay']) {\n      const fid = audits['first-input-delay'];\n      console.log(`⚡ FID: ${fid.displayValue} (${fid.score >= 0.9 ? '🟢' : fid.score >= 0.5 ? '🟡' : '🔴'})`);\n    }\n    \n    if (audits['cumulative-layout-shift']) {\n      const cls = audits['cumulative-layout-shift'];\n      console.log(`📐 CLS: ${cls.displayValue} (${cls.score >= 0.9 ? '🟢' : cls.score >= 0.5 ? '🟡' : '🔴'})`);\n    }\n    \n    // Métriques de performance\n    console.log('\\n⚡ Métriques de Performance:');\n    if (audits['first-contentful-paint']) {\n      console.log(`🎨 FCP: ${audits['first-contentful-paint'].displayValue}`);\n    }\n    if (audits['speed-index']) {\n      console.log(`🏃 Speed Index: ${audits['speed-index'].displayValue}`);\n    }\n    if (audits['total-blocking-time']) {\n      console.log(`⏱️ TBT: ${audits['total-blocking-time'].displayValue}`);\n    }\n    if (audits['interactive']) {\n      console.log(`🖱️ TTI: ${audits['interactive'].displayValue}`);\n    }\n    \n    // Recommandations d'amélioration\n    console.log('\\n💡 Recommandations principales:');\n    const opportunities = Object.entries(audits)\n      .filter(([key, audit]) => audit.details && audit.details.type === 'opportunity' && audit.numericValue > 0)\n      .sort((a, b) => b[1].numericValue - a[1].numericValue)\n      .slice(0, 5);\n    \n    opportunities.forEach(([key, audit]) => {\n      const savings = audit.displayValue || `${Math.round(audit.numericValue)}ms`;\n      console.log(`🔧 ${audit.title}: ${savings} d'économie possible`);\n    });\n    \n    console.log(`\\n📄 Rapport complet sauvegardé: ${reportPath}`);\n    \n    return {\n      configName,\n      scores: Object.fromEntries(\n        Object.entries(lhr.categories).map(([key, data]) => [key, Math.round(data.score * 100)])\n      ),\n      metrics: {\n        lcp: audits['largest-contentful-paint']?.numericValue,\n        fcp: audits['first-contentful-paint']?.numericValue,\n        cls: audits['cumulative-layout-shift']?.numericValue,\n        tbt: audits['total-blocking-time']?.numericValue,\n        tti: audits['interactive']?.numericValue\n      }\n    };\n    \n  } finally {\n    await chrome.kill();\n  }\n}\n\nasync function main() {\n  const url = process.argv[2] || 'http://localhost:3000';\n  const device = process.argv[3] || 'both'; // desktop, mobile, ou both\n  \n  console.log(`🎯 Test Lighthouse pour: ${url}`);\n  console.log(`📱 Device: ${device}`);\n  \n  const results = [];\n  \n  if (device === 'desktop' || device === 'both') {\n    const desktopResult = await runLighthouseTest(url, configs.desktop.settings, configs.desktop.name);\n    results.push(desktopResult);\n  }\n  \n  if (device === 'mobile' || device === 'both') {\n    const mobileResult = await runLighthouseTest(url, configs.mobile.settings, configs.mobile.name);\n    results.push(mobileResult);\n  }\n  \n  // Résumé final\n  console.log('\\n🏆 RÉSUMÉ FINAL');\n  console.log('=' .repeat(50));\n  \n  results.forEach(result => {\n    console.log(`\\n📊 ${result.configName}:`);\n    Object.entries(result.scores).forEach(([category, score]) => {\n      const emoji = score >= 90 ? '🟢' : score >= 50 ? '🟡' : '🔴';\n      console.log(`  ${emoji} ${category}: ${score}/100`);\n    });\n  });\n  \n  console.log('\\n✨ Test terminé !');\n}\n\n// Gestion des erreurs\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('❌ Erreur non gérée:', reason);\n  process.exit(1);\n});\n\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = { runLighthouseTest, configs };\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/scripts/optimize-images.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":1,"column":15,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":1,"endColumn":31},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":2,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":2,"endColumn":25},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ext' is assigned a value but never used.","line":29,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'avifError' is defined but never used.","line":68,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":25}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const sharp = require('sharp');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function optimizeImages() {\n  const publicDir = path.join(__dirname, '..', 'public');\n  const images = [\n    'hero-placeholder.png',\n    //'og.png',\n    // ❌ NE PAS convertir les icônes (compatibilité requise) :\n    // 'favicon.png',\n    // 'icon.png', \n    // 'apple-touch-icon.png',\n    // 'icon-192.png',\n    // 'icon-512.png'\n  ];\n\n  console.log('🚀 Starting image optimization...');\n\n  for (const imageName of images) {\n    const inputPath = path.join(publicDir, imageName);\n    \n    if (!fs.existsSync(inputPath)) {\n      console.log(`⚠️  Skipping ${imageName} - file not found`);\n      continue;\n    }\n\n    const baseName = path.parse(imageName).name;\n    const ext = path.parse(imageName).ext;\n\n    try {\n      // Get original file size\n      const originalStats = fs.statSync(inputPath);\n      const originalSizeKB = Math.round(originalStats.size / 1024);\n\n      console.log(`\\n📸 Processing ${imageName} (${originalSizeKB}KB)...`);\n\n      // Optimize WebP\n      const webpPath = path.join(publicDir, `${baseName}.webp`);\n      await sharp(inputPath)\n        .webp({ \n          quality: 85,\n          effort: 6 \n        })\n        .toFile(webpPath);\n\n      const webpStats = fs.statSync(webpPath);\n      const webpSizeKB = Math.round(webpStats.size / 1024);\n      const webpSavings = Math.round(((originalSizeKB - webpSizeKB) / originalSizeKB) * 100);\n\n      console.log(`✅ WebP: ${webpSizeKB}KB (${webpSavings}% smaller)`);\n\n      // Optimize AVIF (if supported)\n      try {\n        const avifPath = path.join(publicDir, `${baseName}.avif`);\n        await sharp(inputPath)\n          .avif({ \n            quality: 80,\n            effort: 6 \n          })\n          .toFile(avifPath);\n\n        const avifStats = fs.statSync(avifPath);\n        const avifSizeKB = Math.round(avifStats.size / 1024);\n        const avifSavings = Math.round(((originalSizeKB - avifSizeKB) / originalSizeKB) * 100);\n\n        console.log(`✅ AVIF: ${avifSizeKB}KB (${avifSavings}% smaller)`);\n      } catch (avifError) {\n        console.log(`⚠️  AVIF not supported for ${imageName}`);\n      }\n\n      // Generate responsive sizes for hero image\n      if (imageName === 'hero-placeholder.png') {\n        console.log('📱 Generating responsive sizes for hero image...');\n        \n        const sizes = [\n          { width: 640, suffix: '-sm' },\n          { width: 768, suffix: '-md' },\n          { width: 1024, suffix: '-lg' },\n          { width: 1280, suffix: '-xl' },\n          { width: 1920, suffix: '-2xl' }\n        ];\n\n        for (const size of sizes) {\n          // WebP responsive\n          const responsiveWebpPath = path.join(publicDir, `${baseName}${size.suffix}.webp`);\n          await sharp(inputPath)\n            .resize(size.width, null, { \n              withoutEnlargement: true,\n              fit: 'inside'\n            })\n            .webp({ quality: 85 })\n            .toFile(responsiveWebpPath);\n\n          const responsiveStats = fs.statSync(responsiveWebpPath);\n          const responsiveSizeKB = Math.round(responsiveStats.size / 1024);\n          \n          console.log(`  📱 ${size.width}px WebP: ${responsiveSizeKB}KB`);\n        }\n      }\n\n    } catch (error) {\n      console.error(`❌ Error processing ${imageName}:`, error.message);\n    }\n  }\n\n  console.log('\\n🎉 Image optimization complete!');\n}\n\noptimizeImages().catch(console.error);\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/scripts/puppeteer-config.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'puppeteer' is assigned a value but never used.","line":1,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":16},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":1,"column":19,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":1,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const puppeteer = require('puppeteer');\n\n// Configuration Puppeteer pour les captures d'écran\nconst puppeteerConfig = {\n  // Configuration de base\n  headless: 'new',\n  args: [\n    '--no-sandbox',\n    '--disable-setuid-sandbox',\n    '--disable-dev-shm-usage',\n    '--disable-accelerated-2d-canvas',\n    '--no-first-run',\n    '--no-zygote',\n    '--disable-gpu'\n  ],\n  \n  // Configuration pour les captures d'écran\n  defaultViewport: {\n    width: 1280,\n    height: 720,\n    deviceScaleFactor: 1\n  },\n  \n  // Timeouts\n  timeout: 30000,\n  \n  // Configuration réseau\n  ignoreHTTPSErrors: true,\n  \n  // Configuration des ressources\n  ignoreDefaultArgs: ['--disable-extensions']\n};\n\n// Configuration des viewports pour les captures\nconst viewportConfigs = {\n  mobile: {\n    width: 390,\n    height: 844,\n    deviceScaleFactor: 2,\n    isMobile: true,\n    hasTouch: true,\n    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1'\n  },\n  desktop: {\n    width: 1280,\n    height: 720,\n    deviceScaleFactor: 1,\n    isMobile: false,\n    hasTouch: false,\n    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n  }\n};\n\n// Configuration des captures d'écran\nconst screenshotConfig = {\n  // Format PNG (pas de qualité pour PNG)\n  type: 'png',\n  \n  // Capture complète\n  fullPage: true,\n  \n  // Masquer les éléments non nécessaires\n  omitBackground: false,\n  \n  // Capture optimisée\n  captureBeyondViewport: true\n};\n\n// Configuration des attentes\nconst waitConfig = {\n  // Attendre le chargement complet\n  waitUntil: 'networkidle0',\n  \n  // Timeout pour le chargement\n  timeout: 30000,\n  \n  // Attendre les animations\n  animationDelay: 2000,\n  \n  // Attendre les images\n  imageLoadDelay: 1000\n};\n\nmodule.exports = {\n  puppeteerConfig,\n  viewportConfigs,\n  screenshotConfig,\n  waitConfig\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/merci/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/programme/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/robots.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/share/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/share/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/app/sitemap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/AnimatedSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/Footer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/HeroSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/ImageSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/QRCodeSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/ThemeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/ui/badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/ui/button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/recarnot/dev/marche-noel-mpr/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
